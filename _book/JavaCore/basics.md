# Java基础特性

- [Java基本概念](#java基本概念)
  - [Java语言有哪些优点：](#java语言有哪些优点：)
  - [Java和Go的区别](#java和go的区别)
  - [Java和 C/C++有什么异同](#java和-cc有什么异同)
  - [Java中的clone方法有什么作用](#java中的clone方法有什么作用)
- [关键字](#关键字)
  - [static关键字有哪些作用](#static关键字有哪些作用)
  - [volatile有什么作用](#volatile有什么作用)
- [基本类型与运算](#基本类型与运算)
  - [值传递与引用传递有哪些区别](#值传递与引用传递有哪些区别)
- [字符串与数组](#字符串与数组)
  - [“==”、equals和hashCode有什么区别](#、equals和hashcode有什么区别)
  - [请你解释为什么重写equals还要重写hashcode？](#请你解释为什么重写equals还要重写hashcode？)
  - [String、StringBuffer、StringBuilder和StringTokenizer有什么区别](#string、stringbuffer、stringbuilder和stringtokenizer有什么区别)

​        

##  Java基本概念 

### Java语言有哪些优点：

1.  Java为纯面向对象语言
2.  平台无关性。Java为解释型语言，程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。
3.  Java提供了很多内置的类库。提供了对多线程的支持，提供了对网络通信的支持，最重要的是提供了垃圾回收器。
4.  提供了对Web应用开发的支持
5.  具有较好的安全性和健壮性。安全性是指Java运行环境不允许Java程序访问当前浏览器上下文以外的内容。健壮性是指Java提供很多编译时的类型检查和异常处理。
6.  去除了C++语言中难易理解，容易混淆的特性。例如头文件，指针

### java和Go的区别

1. 函数重载。

   Go上不允许函数重载，必须具有方法和函数的唯一名称。java允许函数重载。

2. 多态。

   Java默认允许多态。而Go没有。

3. 继承。

   Go语言的继承通过匿名组合完成：基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承。

   Java的继承通过extends关键字完成，不支持多继承。

4. 传递的值。

   java传递的值为栈中的值（值传递+引用传递）。其中：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递.    

   go就是值传递，所以它是通过指针来完成引用传递

5. 数组。

   Java中直接支持数组这种数据结构，除此之外还有通过数组结构延伸ArrayList.Class int[]，String.Class 的char[] 等。   go 中也支持数组这种数据结构，因为是值传递，所以如何在其他方法中真实的修改数据呢 ，用指针或者Slice。go的指针不能运算。slice 在这方面就是一个数组的view, 但是他的具体结构类似ArrrayList.Class , 它有pre，len ,cap ，类似动态数组

```
ptr : 指定原来数组的首地址值
len : 目前slice的长度
cap : slice的容量 可指定或者是2的倍数
```

​

### Java和 C/C++有什么异同

Java与C++都是面向对象语言，都使用了面向对象思想（封装，继承，多态）

不通点：

1.  Java为**解释型语言**，其运行过程为：Java为解释型语言，程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。

   而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码。   java执行速度比C/C++慢，但是java能够块平台，而C/C++不能

2. Java为纯面向对象语言，所有代码（包括函数、变量等）必须在类中实现，

3. 与C/C++语言相比，Java语言中没有指针的概念

4. Java不支持多重继承，但是Java语言引入了接口的概念，可以同时实现多个接口。由于接口也具有多态特性，因此在Java语言中可以通过实现多个接口来实现与C++语言中多重继承类似的目的。

5. Java语言提供了垃圾回收器来实现垃圾的自动回收，Java语言中虽然没有析构函数，但却引入了一个finalize()方法，当垃圾回收期将要释放无用对象的内存时，会首先调用该对象的finalize()方法，因此，开放人员不需要关心也不需要知道对象所占的内存空间何时会被释放。

### 

### 什么是构造函数### 

### Java中的clone方法有什么作用

Java中所有的类默认都继承自Object类，而Object类中提供了一个clone()方法。这个方法的作用是返回一个Object对象的复制。这个复制函数返回的是一个新的对象，而不是一个引用。

引申：浅复制和深复制有什么区别

浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。

深复制：被复制对象的所有变量都含有与原来对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制的新对象，而不再是原有的那些被引用的对象。换言之，深复制把复制的对象所引用的对象都复制了一遍。

### 什么是反射机制

## 面向对象技术

### 面向对象和面向过程有什么区别

### 面向对象有哪些特征

### 什么是继承

### 组合和继承有什么区别

### 多态的实现机制是什么

### 重载和覆盖有什么区别

### 抽象类（abstract class）与接口（interface）有什么异同

### 如何获取父类的类名

### this与supper有什么区别

## 关键字

### break、continue以及return有什么区别

### final、finally和finalize有什么区别

### static关键字有哪些作用

static关键字主要有两种作用：第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。第二，实现某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性。

具体而言，在Java语言中，static主要有4种使用情况：成员变量，成员方法，代码块和内部类。

1. static成员变量
2. static成员方法
3. static代码块
4. static内部类

### volatile有什么作用

volatile是一个类型修饰符，它是被用来修饰被不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到它时都是直接从对应的内存当中提取，而不会利用缓存，在使用了volatile修饰成员变量后，所有线程在任何时候所看到的变量的值都是相同的。

### instanceof有什么作用

### strictfp有什么作用

关键字strictfp是strict float point 的缩写，指的是精确浮点，它用来确保浮点数运算的准确性。

## 基本类型与运算

### Java提供了哪些基本数据类型

### 什么是不可变类

### 值传递与引用传递有哪些区别

（1）值传递:  在方法调用中，实参会把它的值传递给形参，形参只是用实参的值初始化一个临时的存储单元，因此形参与实参虽然有着相同的值，但是却有着不同的存储单元，因此对形参的改变不会影响实参的值。

（2）引用传递：在方法调用中，传递的是对象（也可以看作是对象的地址），这时形参与实参的对象所指向同一块存储单元，因此对形参的修改就会影响实参的值。

在java语言中，基本数据类型在床底参数是都是按值传递，而包装类型在传递参数时是按引用传递。

- 从概念方面来说
  - 基本类型：变量名指向具体的数值。
  - 引用类型：变量名指向内存数据对象的内存地址
- 从内存方面来说
  - 基本类型：变量在声明之后，Java就会立即分配给他内存空间
  - 引用类型：它以特殊的方式（类似C指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址
- 从使用方面来说
  - 基本类型：使用时需要赋具体值，判断时使用`==`号。
  - 引用类型：使用时可以赋null，判断时使用`equals`方法。



> :point_right: 扩展阅读：[Java 基本数据类型和引用类型](https://juejin.im/post/59cd71835188255d3448faf6)
>
> 这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。

### Math类中round、ceil和floor方法的功能各是什么

## 字符串与数组

### 字符串创建与存储的机制是什么

### “==”、equals和hashCode有什么区别

（1） "=="运算符用来比较两个变量的值是否相等。也就是说，该运算符用于比较变量对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能使用“==”运算符。

（2）equals是Object类提供的方法之一。每一个Java类都继承自Object类，所以每一个对象都具有equals这个方法。Object类中定义的equlas(Object)方法是直接使用“==”运算符比较的两个对象，所以在没有覆盖equlas(Object)方法的情况下，equlas(Object)与“==”运算符一样，比较的是引用。

​      相比“==”运算符，equlas(Object)方法的特殊之处就在于它可以被覆盖，所以可以通过覆盖的方法让它不是比较引用而是比较数据内容，例如String类的equlas方法是用于比较两个独立对象的内容是否相同，即堆中的内容是否相同。

​      如果一个类没有自己定义equlas()方法，它默认的equal()方法(从Object类继承的)就是使用"=="运算符，也是在比较两个变量指向的对象是否是同一对象，此时使用equlas()方法和使用“==”运算符会得到相同的结果。若比较的是两个独立的对象，则总返回false。如果编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么必须覆盖equlas()方法。由开发人员自己编写代码来决定在什么情况下即可认为连个对象的内容是相同的。

（3）hashCode()方法是从Object类中继承过来的，它也用来鉴定两个对象是否相等。Object类中的hashCode()方法返回对象在内存中地址转换成的一个int值，所以如果没有重写hashCode()方法，任何对象的hashCode()方法都是不想等的。

​    hashCode()方法的返回值和equals()方法的关系如下：

​    如果x.equals(y)返回true，即两个对象根据equals方法比较是相等的，那么调用者两个对象中任意一个对象的hashCode()方法都必须产生同样的整数结果。如果x.equals(y)返回false，即两个对象根据equals()方法比较是不相等的，那么x和y的hashCode()方法的返回值有可能相等，也有可能不相等。

   反之，hashCode()方法的返回值不相等，一等能推出equals()方法的返回值也不相等，而hashCode()方法的返回值相等，equals()方法的返回值则可能相等，也可能不相等。

### 请你解释为什么重写equals还要重写hashcode？

HashMap中，如果要比较key是否相等，要同时使用这两个函数！

因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素 是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。

### String、StringBuffer、StringBuilder和StringTokenizer有什么区别

- String： 如果要操作的数据量比较小，应优先使用String类
- StringBuilder：如果是在单线程下操作大量数据，应优先使用StringBuilder。（效率最高）
- StringBuffer：  如果是在多线程下操作大量数据，应优先使用StringBuffer。（线程安全）但一个字符串需要经常被修改时。

### Java中数组是不是对象

### length属性与length()方法有什么区别

在java语言中，

- 数组提供了length属性来获取数组的长度
- length()方法是针对字符串而言的
- size()方法是针对泛型集合而言的，用于查看泛型中有多少个元素



## 异常处理

