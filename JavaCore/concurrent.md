# 并发

## 1.并发简介

### 1.1. 什么是进程？什么是线程？进程和线程的区别？

### 1.2. 并发（多线程）编程的好处是什么？

### 1.3. 并发一定比串行更快吗？

### 1.4. 如何让正在运行的线程暂停一段时间？

### 1.5. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

### 1.6. 在多线程中，什么是上下文切换(context-switching)？

### 1.7. 如何确保线程安全？

### 1.8. 什么是死锁(Deadlock)？如何分析和避免死锁？

## 2.线程基础

### 2.1. Java 线程生命周期中有哪些状态？各状态之间如何切换？

### 2.2. 创建线程有哪些方式？这些方法各自利弊是什么？

### 2.3. 什么是 Callable 和 Future？什么是 FutureTask？

### 2.4. start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？

### 2.5. sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？

### 2.6. Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？

### 2.7. 什么是守护线程？为什么要用守护线程？如何创建守护线程？

### 2.8. 线程间是如何通信的？

### 2.9. 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？

### 2.10. 为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？

## 3.并发机制的底层实现

### 3.1. volatile 有什么作用？它的实现原理是什么？

### 3.2. synchronized 有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？

### 3.3. volatile 和 synchronized 的区别？

### 3.4. ThreadLocal 有什么作用？ThreadLocal 的实现原理是什么？

## 4.内存模型

### 4.1. 什么是 Java 内存模型

## 5.同步容器和并发容器

### 5.1. 什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？

### 5.2. 什么是并发容器的实现？

## 6.锁

### 6.1. 如何避免死锁？

### 6.2. Lock 接口(Lock interface)是什么？对比同步它有什么优势？

### 6.3. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？

## 7.原子变量类

### 7.1. 什么是原子操作？有哪些原子类？原子类的实现原理是什么？

## 8.并发工具类

### 8.1. CyclicBarrier 和 CountDownLatch 有什么不同？

## 9.线程池

### 9.1. 什么是线程池？如何创建一个 Java 线程池？

### 9.2. 什么是 Executors 框架？

### 9.3. Executors 类是什么？

### 9.4. ThreadPoolExecutor 有哪些参数，各自有什么用？

### 9.5. 线程数多少才合理

## 10.资料